// genAuth() returns string used as the Authorization header for the request
// Example:
//      POST /1.1/statuses/update.json?include_entities=true HTTP/1.1
//      Accept: */*
//      Content-Type: application/x-www-form-urlencoded
//      Authorization: [string generated by genAuth]

// Generate signature:
// REF: https://dev.twitter.com/oauth/overview/creating-signatures
//      1. oauth key-value pairs, percent encoded
//      2. request parameters, percent encoded
//      3. combine paris in 1 & 2 to str SORTED by keys
//      4. combine method & encode(url) & encoded(3) (Exactly 2 '&' chars)
//      5. get signing key from consumer/token secret(s)
//      6. calculate signature from 4 & 5

// Generate header:
// REF: https://dev.twitter.com/oauth/overview/authorizing-requests
// (BUT SEE BELOW FOR POTENTIAL ERROR)
//      1. oauth key-value pairs, plus the signature, percent encoded
//              7 keys in all normal cases, step 1 of sign-in flow
//              8 keys in step 3 of sign-in flow
//      2. note: query parameters should not be included
//      3. note: header generation must use the same values for keys
//          used in signing (esp. nonce and timestamp)
//      4. note: key order does not matter

// Signature needs:   oauth_params + request_params, sorted
// Header needs:      oauth_params (ALL but secrets, including 
//                oauth_signature, oauth_callback, or oauth_verifier)
//      SPECIAL CASE: in step 1 or 3 of the sign-in flow, there is an 
//          extra oauth parameter (oauth_callback/verifier) that both 
//          (1) is part of the POST data (thus needed for signature) and 
//          (2) should also be kept in the header
//          Those are the only two places where the header includes a key
//          that's also part of the POST request data
//      TWITTER DOC EXAMPLE FOR STEP 3 AT 
//          https://dev.twitter.com/web/sign-in/implementing
//          SEEMS WRONG IN NOT INCLUDING VERIFIER
//      This actually amounts to using all oauth_* in the header, except
//          for the secrets which are used only as signing keys.
//          To handle these cases, simple strip everything that is not
//          oauth_* from the header keys


// Be careful not to modify the external parameter/token collections if
//      passed in! Work on a local object.

var querystring = require('querystring');
var crypto = require('crypto');
var fs = require('fs');

var appkeys = require('./index');

function gnonce() {
    function s4() {
        // This generates a relatively random 4-char str
        //      A base 1 is added and then stripped to ensure that 
        //      there are no less then 4 chars in the str
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    return s4() + s4() + s4() + s4() +
    s4() + s4() + s4() + s4();
}


function gen(method, requesturl, reqParams, tokens) {
    // tokens may contain oauth_token, or oauth_token and oauth_token_secret
    // returns the string used as the Authorization header for the request

    var consumerKey = appkeys.consumerKey;
    var consumerSecret = appkeys.consumerSecret;
    // console.log('App keys:\n' + consumerKey + '\n' + consumerSecret);

    var params = {};
    // Using percent encoded key-pair values from the very
    //      beginning, as we will need to sort the encoded keys
    params[encodeURIComponent('oauth_consumer_key')] =
        encodeURIComponent(consumerKey);
    params[encodeURIComponent('oauth_nonce')] =
        encodeURIComponent(gnonce());
    params[encodeURIComponent('oauth_signature_method')] =
        encodeURIComponent('HMAC-SHA1');
    params[encodeURIComponent('oauth_timestamp')] =
        encodeURIComponent(Math.floor(Date.now() / 1000).toString());
    params[encodeURIComponent('oauth_version')] =
        encodeURIComponent('1.0');

    if (tokens.hasOwnProperty('oauth_token')) {
        params[encodeURIComponent('oauth_token')] = 
            encodeURIComponent(tokens['oauth_token']);
    }

    for (key in reqParams) {
        params[encodeURIComponent(key)] = reqParams[key];
    }

    // Creating signature base string    
    var sigBase = method.toUpperCase();
    sigBase += '&' + encodeURIComponent(requesturl);

    var paramStr = '';
    var paramKeys = Object.keys(params).concat().sort();
    for (key of paramKeys) {
        paramStr += '&' + key + '=' + params[key];
    }
    sigBase += '&' + encodeURIComponent(paramStr.slice(1));

    // Creating signing key
    var signingKey = encodeURIComponent(consumerSecret) + '&';
    if (tokens.hasOwnProperty('oauth_token_secret')) {
        signingKey += encodeURIComponent(tokens['oauth_token_secret']);
    }

    // Calculating signature
    console.log('Base:\n' + sigBase);
    console.log('Key:\n' + signingKey);
    var signature = crypto.createHmac(
            'sha1', signingKey).update(sigBase).digest().toString('base64');
    // console.log('Signature (pre-encode): ' + signature);

    // Adding signature to the parameter list
    params[encodeURIComponent('oauth_signature')] =
        encodeURIComponent(signature);

    // Strip non oauth_* keys from the list
    for (key in reqParams) {
        if (key.slice(0,6) != 'oauth_')
            delete params[encodeURIComponent(key)];
    }

    // Generating auth header, keys not ordered
    var dst = '';
    for (key in params) {
        dst += ', ' + key + '="' + params[key] + '"'
    }
    dst = 'OAuth ' + dst.slice(2);

    console.log('Header Authorization value:\n' + dst);
    return dst;
}

exports.gen = gen;